<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浮动]]></title>
    <url>%2F%E6%B5%AE%E5%8A%A8.html</url>
    <content type="text"><![CDATA[最近在学浮动的知识，下面总结了一些浮动的一些特征1. 块级元素浮动将并排显示，不再独占一行示例代码：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box2&#123; width: 100px; height: 100px; border: 1px solid #ccc; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;效果：修改：123456789&lt;style&gt; .box2&#123; width: 100px; height: 100px; border: 1px solid #ccc; background-color: skyblue; float: left;/*新增*/ &#125;&lt;/style&gt;修改效果：2. 内联样式浮动就可以设置宽高，不仅能够支持margin-left(right)，而且也支持margin-top(bottom)示例代码：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box2&#123; width: 20px;/*无效*/ height: 70px;/*无效*/ border: 1px solid #ccc; margin-top: 20px;/*无效*/ padding: 100px 30px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class="box2"&gt;&lt;/span&gt; &lt;span class="box2"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;效果：修改：123456789101112131415&lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box2&#123; width: 20px;/*生效*/ height: 70px;/*生效*/ border: 1px solid #ccc; margin-top: 20px;/*生效*/ padding: 100px 30px; background-color: skyblue; float: left;/*新增*/ &#125;&lt;/style&gt;修改效果：3. 浮动元素脱离正常的文档流,普通元素会占据浮动元素的位置从上图可以看出，默认三个设置了宽高的block元素，本来会格子独占一行；如果框1设置了向左/向右浮动，他会忽略框2和框3，直到碰到父元素；同时也存在盖住普通元素的风险。4. 浮动会导致父元素高度坍塌示例代码：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="border: solid 5px #0e0; width:300px;"&gt; &lt;div style="height: 100px; width: 100px; background-color: Red; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Green; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Yellow; float:left;"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;效果：如上图所示，浮动元素脱离了文档流，并不占据文档流的位置，自然父元素也就不能被撑开，所以没了高度，导致父元素高度坍塌。浮动元素对父元素的影响对父容器 若子元素都是浮动元素，则无法撑开父元素高度，父元素失去高度。浮动元素其他浮动元素的影响对其他浮动元素，如果包含块太窄，无法完全水平容纳浮动元素，那么其他浮动元素就会向下移动，直到有足够空间。如果浮动元素高度不同，那么向下移动时可能会被卡住。示例代码1（块太窄，向下移动）：12345678&lt;div style="border: solid 5px #0e0; width:250px;"&gt; &lt;div style="height: 100px; width: 100px; background-color: Red; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Green; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Yellow; float:left;"&gt; &lt;/div&gt;&lt;/div&gt;效果：示例代码2（卡住）:12345678&lt;div style="border: solid 5px #0e0; width:250px;"&gt; &lt;div style="height: 120px; width: 100px; background-color: Red; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Green; float:left;"&gt; &lt;/div&gt; &lt;div style="height: 100px; width: 100px; background-color: Yellow; float:left;"&gt; &lt;/div&gt;&lt;/div&gt;效果：浮动元素对普通元素的影响普通元素会表现得当作浮动元素不存在一样，浮动元素可以覆盖普通元素，如果宽高合适，普通元素可以占据浮动元素原来的位置对文字的影响文字(既inline-level)级的元素会环绕浮动元素，表现的像是察觉到浮动元素一样。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题个性化教程:打造炫酷网站]]></title>
    <url>%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[看到有些next主题的网站很炫酷，那么是怎么配置的呢？接下来我会讲一讲如何实现一些炫酷的效果主要有以下29种：在右上角或者左上角实现fork me on github添加RSS添加动态背景实现点击出现桃心效果修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改``代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动侧边栏推荐阅读1. 在右上角或者左上角实现fork me on github实现效果图具体实现方法点击这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码：然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址2.添加RSS实现效果图具体实现方法切换到你的blog（我是取名blog，具体的看你们的取名是什么）的路径，例如我是在/Users/chenzekun/Code/Hexo/blog这个路径上，也就是在你的根目录下然后安装 Hexo 插件：(这个插件会放在node_modules这个文件夹里)1$ npm install --save hexo-generator-feed接下来打开画红线的文件，如下图：在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！)123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格)1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml配置完之后运行：1$ hexo g重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。3. 添加动态背景实现效果图具体实现方法这个我之前有一篇文章有讲过了，详情点击我的博客4. 实现点击出现桃心效果实现效果图具体实现方法在网址输入如下1http://7u2ss1.com1.z0.glb.clouddn.com/love.js然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt;5. 修改文章内链接文本样式实现效果图具体实现方法修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。6. 修改文章底部的那个带#号的标签实现效果图具体实现方法修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;7. 在每篇文章末尾统一添加“本文结束”标记实现效果图具体实现方法在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt;接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）：代码如下：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;然后打开主题配置文件（_config.yml),在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。8. 修改作者头像并旋转实现效果图具体实现方法打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;9. 博文压缩在站点的根目录下执行以下命令：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save在如下图所示，新建 gulpfile.js ，并填入以下内容：123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']);生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。10. 修改``代码块自定义样式实现效果图具体实现方法打开\themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义)123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125;11. 侧边栏社交小图标设置实现效果图具体实现方法打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可12. 主页文章添加阴影效果实现效果图具体实现方法打开\themes\next\source\css\_custom\custom.styl,向里面加入：12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;13. 在网站底部加上访问量实现效果图具体实现方法打开\themes\next\layout_partials\footer.swig文件,在copyright前加上画红线这句话：代码如下：1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;然后再合适的位置添加显示统计的代码，如图：代码如下：12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;在这里有两中不同计算方式的统计代码：pv的方式，单个用户连续点击n篇文章，记录n次访问量123&lt;span id="busuanzi_container_site_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;uv的方式，单个用户连续点击n篇文章，只记录1次访客数123&lt;span id="busuanzi_container_site_uv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;次&lt;/span&gt;添加之后再执行hexo d -g，然后再刷新页面就能看到效果14. 添加热度实现效果图具体实现方法next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃：然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了15. 网站底部字数统计实现效果图具体方法实现切换到根目录下，然后运行如下代码1$ npm install hexo-wordcount --save然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt;16. 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为1skip_render: README.md保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。17. 设置网站的图标Favicon实现效果图具体方法实现在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件：12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico18. 实现统计功能实现效果图具体实现方法在根目录下安装 hexo-wordcount,运行：1$ npm install hexo-wordcount --save然后在主题的配置文件中，配置如下：123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true19. 添加顶部加载条实现效果图具体实现方法打开/themes/next/layout/_partials/head.swig文件，添加红框上的代码代码如下：12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面）12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt;目前，博主的增加顶部加载条的pull request 已被Merge😀===&gt;详情现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条，如下图：20. 在文章底部增加版权信息实现效果图在目录 next/layout/_macro/下添加 my-copyright.swig：1234567891011121314151617181920212223242526272829303132&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125;在目录next/source/css/_common/components/post/下添加my-post-copyright.styl：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125;修改next/layout/_macro/post.swig，在代码12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;之前添加增加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;如下：修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码：1@import "my-post-copyright"保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似：小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。21. 添加网易云跟帖(跟帖关闭，已失效)实现效果图具体方法实现有两种实现方法：①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件_config.yml 文件中添加如下配置:1gentie_productKey: #your-gentie-product-key②如果你不想更新的话，那么按下面步骤进行：首先，还是在主题配置文件_config.yml 文件中添加如下配置:1gentie_productKey: #your-gentie-product-key你的productKey就是下面画红线部分然后在在layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下：1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: "", productKey: "&#123;&#123;gentie_productKey&#125;&#125;", target: "cloud-tie-wrapper" &#125;; &lt;/script&gt; &lt;script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125;然后在layout/_scripts/third-party/comments.swig文件中追加：1&#123;% include './comments/gentie.swig' %&#125;最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑：123&#123;% elseif theme.gentie_productKey %&#125; &lt;div id="cloud-tie-wrapper" class="cloud-tie-wrapper"&gt; &lt;/div&gt;具体位置如下：可能你hexo s时可能看不到，直接hexo d就可以看到了22. 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图：23. 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：，然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。24. 文章加密访问实现效果图具体实现方法打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码：代码如下：12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;然后在文章上写成类似这样：25. 添加jiathis分享在主题配置文件中，jiathis为true，就行了，如下图默认是这样子的：如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改画红线部分就可以了26. 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;;在文章中添加 top 值，数值越大文章越靠前，如12345678---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100---27. 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base =16px28. 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下：123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/29. 侧边栏推荐阅读今天有位网友问推荐阅读是怎么弄，其实挺简单的，打开主题配置文件修改成这样就行了(links里面写你想要的链接):1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/致谢感谢大神们的文章，真的学到了许多，有些忘了记录下来，在这里由衷的感谢。虽然比较折腾，但是确实满满的成就感，Road endless its long and far, I will seek up and down！欢迎访问我的博客参考的文章：http://blog.csdn.net/MasterAnt_D/article/details/56839222http://zidingyi4qh.com/2017/04/27/NexT%E5%BA%95%E9%83%A8logo%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F/https://fuyis.me/2017/01/25/Hexo-theme-next-and-optimized-configuration/http://www.vitah.net/posts/20f300cc/http://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端小项目：使用canvas绘画哆啦A梦]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%B0%8F%E9%A1%B9%E7%9B%AE%EF%BC%9A%E4%BD%BF%E7%94%A8canvas%E7%BB%98%E7%94%BB%E5%93%86%E5%95%A6A%E6%A2%A6.html</url>
    <content type="text"><![CDATA[最近在学canvas元素,&lt;canvas&gt;标签只是图形容器，必须使用js来绘制图形。为了增强对canvas元素的理解,于是用canvas画了一个哆啦A梦来要实现的效果图在线预览要想绘画出这个哆啦a梦首先要掌握以下一些函数：arcTo()canvas绘制圆形或弧线bezierCurveTo()quadraticCurveTo()开始绘画！！首先我们需要创建一个400*600的画布，代码如下:1&lt;canvas id="doraemon" width="400" height="600"&gt;&lt;/canvas&gt;接着定义一个div，用来显示坐标1&lt;div id="put" style="width: 50px" height="20px"&gt;&lt;/div&gt;接着我写了一个显示坐标的函数，可以用来看大概画到哪个点：123456function zuobiao(event) &#123; var x = event.clientX; var y = event.clientY; var out = document.getElementById("put"); out.innerHTML = "x:" + x + " y:" + y; &#125;然后getContext() 方法返回一个用于在画布上绘图的环境。1var cxt = document.getElementById('doraemon').getContext('2d');接着开始画头部:1234567cxt.beginPath();//起始路径cxt.lineWidth = 1;//线宽度为1cxt.strokeStyle = '#000';//笔触的颜色cxt.arc(200, 175, 175, 0.7 * Math.PI, 0.3 * Math.PI);//绘制弧，中心点（200，175），半径175cxt.fillStyle = '#0bb0da';//设置填充时的颜色cxt.fill();//填充颜色cxt.stroke();//绘制路径头部如下：接着绘画出脸部：123456789cxt.beginPath();cxt.fillStyle = '#fff';cxt.moveTo(110, 110);//将路径移到点（110，110），不创建线条cxt.quadraticCurveTo(-10, 200, 120, 315);//创建二次贝塞尔曲线,控制点(-10,200),结束点(120,315)cxt.lineTo(280, 315);//添加一个新点，然后在画布中创建从（110，110）到（280，315）的线条cxt.quadraticCurveTo(410, 210, 290, 110);cxt.lineTo(110, 110);cxt.fill();cxt.stroke();脸部如下：接着绘画眼睛：1234567891011cxt.beginPath();cxt.lineWidth = 1;cxt.fillStyle = '#fff';cxt.moveTo(110, 110);cxt.bezierCurveTo(110, 25, 200, 25, 200, 100);//创建三次贝塞尔曲线,控制点1(110,25),控制点2(200,25),结束点(200,100)，也就是画左上半椭圆cxt.bezierCurveTo(200, 175, 110, 175, 110, 100);//画左下半椭圆cxt.moveTo(200, 100);cxt.bezierCurveTo(200, 25, 290, 25, 290, 100);cxt.bezierCurveTo(290, 175, 200, 175, 200, 100);cxt.fill();cxt.stroke();接着画左右眼球：123456789101112 /*右眼球*/cxt.beginPath();cxt.fillStyle = '#000';cxt.arc(230, 130, 12, 0, 2 * Math.PI);cxt.fill();cxt.stroke();/*左眼球*/cxt.beginPath();cxt.fillStyle = '#000';cxt.arc(170, 130, 12, 0, 2 * Math.PI);cxt.fill();cxt.stroke();左右眼球：接着画鼻子：12345cxt.beginPath();cxt.arc(200, 165, 25, 0, 2 * Math.PI);cxt.fillStyle = '#d05823';cxt.fill();cxt.stroke();鼻子：接着画胡须：12345678910111213141516171819//左胡须cxt.beginPath();cxt.moveTo(80, 175);cxt.lineTo(150, 195);cxt.moveTo(80, 200);cxt.lineTo(150, 205);cxt.moveTo(80, 225);cxt.lineTo(150, 215);//中部胡须cxt.moveTo(200, 195);cxt.lineTo(200, 290);//右胡须cxt.moveTo(250, 195);cxt.lineTo(320, 175);cxt.moveTo(250, 205);cxt.lineTo(320, 200);cxt.moveTo(250, 215);cxt.lineTo(320, 225);cxt.stroke();胡须:接着画嘴：123cxt.moveTo(80, 240);cxt.quadraticCurveTo(200, 350, 320, 240);cxt.stroke();嘴：接下来画围巾：123456789101112131415cxt.beginPath();cxt.moveTo(96, 316);cxt.lineTo(305, 316);cxt.lineTo(320, 316);cxt.arcTo(330, 316, 330, 326, 10);//在画布上创建介于两个切线之间的弧，起点坐标为(330,316),终点坐标为(330,326),半径为10cxt.lineTo(330, 336);cxt.arcTo(330, 346, 305, 346, 10);cxt.lineTo(81, 346);cxt.arcTo(71, 346, 71, 336, 10);cxt.lineTo(71, 326);cxt.arcTo(71, 316, 81, 316, 10);cxt.lineTo(96, 316);cxt.fillStyle = '#b13209';cxt.fill();cxt.stroke();围巾：接着画衣服：1234567891011121314151617cxt.beginPath();cxt.fillStyle = '#0bb0da';cxt.moveTo(80, 346);//左衣服cxt.lineTo(26, 406);cxt.lineTo(65, 440);cxt.lineTo(85, 418);cxt.lineTo(85, 528);cxt.lineTo(185, 528);//右衣服cxt.lineTo(315, 528);cxt.lineTo(315, 418);cxt.lineTo(337, 440);cxt.lineTo(374, 406);cxt.lineTo(320, 346);cxt.fill();cxt.stroke();衣服：接着画手：123456789101112//左手cxt.beginPath();cxt.fillStyle = '#fff';cxt.arc(37, 433, 30, 0, 2 * Math.PI);cxt.fill();cxt.stroke();//右手cxt.beginPath();cxt.fillStyle = '#fff';cxt.arc(363, 433, 30, 0, 2 * Math.PI);cxt.fill();cxt.stroke();手：接着画肚：12345cxt.beginPath();cxt.fillStyle = '#fff';cxt.arc(200, 400, 91, 1.8 * Math.PI, 1.2 * Math.PI);cxt.fill();cxt.stroke();肚：接着画小口袋12345678cxt.beginPath();cxt.fillStyle = '#fff';cxt.moveTo(130, 394);cxt.lineTo(270, 394);cxt.moveTo(130, 394);cxt.bezierCurveTo(130, 490, 270, 490, 270, 394);cxt.fill();cxt.stroke();小口袋：最后画两只脚以及两只脚的的空隙：1234567891011121314151617181920212223242526272829/*两只脚的空隙*/ cxt.beginPath(); cxt.fillStyle = '#fff'; cxt.arc(200, 529, 20,Math.PI, 0); cxt.fill(); cxt.stroke(); /*脚*/ //左脚 cxt.beginPath(); cxt.fillStyle='#fff'; cxt.moveTo(180,528); cxt.lineTo(72,528); cxt.bezierCurveTo(52,528,52,558,72,558); cxt.lineTo(180,558); cxt.moveTo(180,558); cxt.bezierCurveTo(200,558,200,528,180,528); cxt.fill(); cxt.stroke(); //右脚 cxt.beginPath(); cxt.fillStyle='#fff'; cxt.moveTo(220,528); cxt.lineTo(328,528); cxt.bezierCurveTo(348,528,348,558,328,558); cxt.lineTo(220,558); cxt.moveTo(220,558); cxt.bezierCurveTo(200,558,200,528,220,528); cxt.fill(); cxt.stroke();完成了︿(￣︶￣)︿完整代码请点击：哆啦A梦]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关HTML常被问到的知识点]]></title>
    <url>%2F%E6%9C%89%E5%85%B3HTML%E5%B8%B8%E8%A2%AB%E9%97%AE%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
    <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别?HTML即是超文本标记语言（Hyper Text Markup Language），是最早写网页的语言，但是由于时间早，规范不是很好，大小写混写且编码不规范,是语法较为松散的、不严格的Web语言XHTML是升级版的html（Extensible Hyper Text Markup Language），对html进行了规范，编码更加严谨纯洁，也是一种过渡语言，html向xml过渡的语言。实际上XHTML 与 HTML 4.01 标准没有太多的不同。XML是可扩展标记语言（Extensible Markup Language），是一种跨平台语言，编码更自由，可以自由创建标签（比如像下面这样创建：123456&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt;），主要用于存储数据和结构，可扩展HTML和XML的区别：XML 被设计用来传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息，而 XML 旨在传输信息。XML在定义标记时区分大小写，而HTML标记不区分大小写。HTML和XHTML的区别：XHTML 元素必须被正确地嵌套。例如：XHTML必须要这样&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;而在 HTML 中，某些元素可以像这样彼此不正确地嵌套：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;XHTML 元素必须被关闭。例如&lt;p&gt;This is a paragraph&lt;/p&gt;===&gt;&gt;这是正确的&lt;p&gt;This is a paragraph===&gt;&gt;这是错误的标签名必须用小写字母。例如: &lt;p&gt;This is a paragraph&lt;/p&gt;==&gt;&gt;这是正确的&lt;P&gt;This is a paragraph&lt;/P&gt;===&gt;&gt;这是错误的XHTML 文档必须拥有根元素。所有的 XHTML 元素必须被嵌套于 &lt;html&gt; 根元素中怎样理解 HTML 语义化?HTML语义化是让大家直观的认识标签(markup)和属性(attribute)的用途和作用，选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析，并且便于团队开发和维护。怎样理解内容与样式分离的原则?写 HTML 的时候先不管样式, 重点放在HTML的结构和语义化上，让 HTML 能体现页面结构或者内容。之后再去写样式。写 JS 的时候，尽量不要用 JS 去直接操作样式，而是通过给元素添加删除class来控制样式变化。文档结构与文档样式的分离可以确保网页的平稳退化，也让内容和样式在可以分开独立编辑。有哪些常见的meta标签?指定字符集&lt;meta charset=&quot;utf-8&quot;&gt;向搜索引擎说明你的网页的关键词&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;告诉搜索引擎你的站点的主要内容&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;告诉搜索引擎你的站点的制作的作者&lt;meta name=&quot;author&quot; content=&quot;your name&quot;&gt;响应式页面&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;定时让网页在3秒内跳转到mozilla首页(http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。)&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3&quot; url=https://www.mozilla.org&quot;&gt;如果安装了GCF (Google Chrome Frame)，则使用GCF来渲染页面 (“chrome=1”), 如果没有安装GCF，则使用最高版本的IE内核进行渲染 (“IE=edge”)。X-UA-Compatible(浏览器采取何种版本渲染当前页面)&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;浏览器的内核控制&lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt;文档声明的作用?文档声明用来告知浏览器当前文档所使用的类型，让浏览器解析器知道要用什么规范来解析文档。严格模式和混杂模式指什么?在严格模式中，浏览器以其支持的最高标准呈现页面。在混杂模式中，又称怪异模式或兼容模式，浏览器用自己的方式解析代码，页面以一种比较宽松的向后兼容的方式显示。混杂模式通常模拟老式浏览器的行为以防止老站点无法工作。&lt;!doctype html&gt; 的作用?它是html5标准网页声明,告诉浏览器用最新的 HTML5标准来解析渲染页面；如果不写，浏览器就会进入混杂模式。浏览器乱码的原因是什么？如何解决？乱码产生的根本原因是保存的编码格式和浏览器解析时的解码格式不匹配导致的。解决方式： 写代码的时候在html 的 &lt;head&gt;里添加&lt;meta charset=&#39;xxx&#39;&gt;并且保存的时候仍选择同样的编码方式。常见的浏览器有哪些？什么内核？Internet explorer 使用的是TridentFirefox使用的是Gecko。opera之前使用的是Presto，后来用Blink苹果的Safari，谷歌的Chrome使用的是WebKit，还有国产的大部分双核浏览器其中一核就是WebKit。列出常见的标签，并简单介绍这些标签用在什么场景？标签运用场景&lt;html&gt;HTML 页面的根元素&lt;body&gt;文档的内容&lt;head&gt;用于定义文档的头部&lt;meta&gt;提供了元数据.元数据也不显示在页面上，被浏览器解析&lt;title&gt;文档的标题&lt;h1&gt;-&lt;h6&gt;定义了一级标题到六级标题，标题字体大小逐渐减弱&lt;p&gt;定义一个段落&lt;a&gt;网页链接&lt;div&gt;块级元素，它可用于组合其他 HTML 元素的容器,没有特定的含义&lt;span&gt;内联元素，也没有特定的含义，可用作文本的容器&lt;u&gt;下划线&lt;em&gt;强调文本&lt;strong&gt;加重文本&lt;ol&gt;有序列表&lt;ul&gt;无序列表&lt;li&gt;定义列表项目&lt;img&gt;图片&lt;br &gt;换行&lt;input&gt;定义输入控件&lt;i&gt;斜体字&lt;table&gt;定义表&lt;tr&gt;定义表格中的行&lt;td&gt;定义表中的单元格&lt;th&gt;定义表格的表头&lt;tbody&gt;定义表格的主体&lt;tfoot&gt;定义表格的页脚&lt;hr&gt;创建一条水平线&lt;iframe&gt;定义内联框架&lt;cite&gt;定义作品的标题&lt;button&gt;按钮&lt;b&gt;定义粗体文本&lt;form&gt;定义用于用户输入的HTML表单&lt;caption&gt;定义表标题&lt;footer&gt;定义文档或节的页脚]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Charles乱码问题]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3Charles%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[在网上查了半天说在Info.plist文件加字符串就好了，其实没有用，下面有一个方法亲试可以解决乱码问题安装ssl证书3.10版本之前的需要去http://www.charlesproxy.com/ssl.zip 下载 CA 证书文件，然后双击 .crt 文件，选择‘总是信任’按钮，在钥匙串访问中即可看到添加成功的证书。我是4.02版本的，在3.10版本之后的，操作如下：先点proxy中的macOS Proxy ，如果点击网页，Charles没有出现东西的话，把翻墙软件关了然后点击help中的SSL Proxying如下图：点击之后在搜索框中输入Charles，出现（我是已经改好了，原来的话是红色的）：双击那个证书，改成如下图所示，然后保存：接下来点击proxy中的SSL Proxying Settings，出现如下图所示，然后点add 在Host里填 * 号 ，在Port里填443，然后点ok：接下来，你会惊奇的发现，乱码没有了\（￣︶￣）/]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github博客绑定个性域名]]></title>
    <url>%2Fgithub%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%B8%AA%E6%80%A7%E5%9F%9F%E5%90%8D.html</url>
    <content type="text"><![CDATA[首先我们先买个域名,可以在阿里云购买域名，买完之后登陆阿里云的管理控制台,然后点击域名，再点击解析如下接下来点击添加解析，并输入以下信息（记录值不一样，第一个的记录值填你的github访问地址,如shenzekun.github.io,第二个填的是你的网站的ip地址，比如我原来的网站是shenzekun.github.io,那么就查找shenzekun.github.io的ip地址，网站的ip地址可以在这查ip地址）然后向你的 Github Pages 仓库添加一个CNAME(一定要大写)文件，在CNAME里面添加你的域名信息（不加http://），如shenzekun.cn,并上传到你的GitHub中填完之后登陆你博客的github，点击setting在这填写你的域名，点击保存即可接下来就是等了，我的博客大概半个小时就可以看到了。😝]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学生免费申请JetBrains许可证技巧]]></title>
    <url>%2F%E5%AD%A6%E7%94%9F%E5%85%8D%E8%B4%B9%E7%94%B3%E8%AF%B7JetBrains%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%8A%80%E5%B7%A7.html</url>
    <content type="text"><![CDATA[用过JetBrain公司出的软件的人都知道，这个公司出的软件都比较好用，像webstorm，phpstrom等等，但是就是太贵了。对于学生，可以免费使用jetbrain公司的软件，那么接下来我会讲一讲如何申请免费学生免费申请许可证地址：https://www.jetbrains.com/student/点击apply now出现如下图：支持的验证方法有：邮件认证: 如果你的学校对学生有提供类似@.edu或者是 @.edu.cn 的邮箱，那么你可以通过这种方式去认证。ISIC/ITIC 认证： 这个没试过，不知道要怎么弄 —__—文档认证： 我是申请这个的，这个需要你的学生证 ===&gt;这里填你的学校就行了！Comment里面填一些你想说的话，然后点APPLY FOR FREE PRODUCTS，就申请完成了!等我是星期六申请的，星期一晚上就发邮件给我了，大约用了3天左右，如图：点 Activate Educational License就激活成功了！我用phpstrom举例子在这里输入你获得的许可证就能成功激活了。注意，许可证有效期为1年!（过期了可重新申请）]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题：从url到页面展现，这之中发生了什么？]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BB%8Eurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%EF%BC%8C%E8%BF%99%E4%B9%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.html</url>
    <content type="text"><![CDATA[我们平常在地址栏里输入一些网址时，页面很快就会出现，但在这之中到底发生了什么事情呢？大概是这样的流程：在浏览器的地址栏中敲入了url域名解析服务器处理请求浏览器处理绘制网页一、在浏览器的地址栏中敲入了url首先，我们要知道url是什么？URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上的资源，实际上就是网站网址。url的格式一般为：协议类型://&lt;主机名&gt;:&lt;端口&gt;/&lt;路径&gt;/文件名其中协议类型可以是http（超文本传输协议）、https、ftp（文件传输协议）、telnet（远程登录协议）、file等等。而http是最常见的网络传输协议，https则是进行加密的网络传输。例如，我的简书url为http://www.jianshu.com/u/b473784d730c，其中，“http”表示与web服务器通讯采用http协议，简书web服务器域名为www.jianshu.com，u/b473784d730c表示所访问的文件存在于web服务器上的路径。url格式中主机名冒号后面的数字是端口编号，因为一台计算机常常会同时作为Web，FTP等服务器，端口编号用来告诉web服务器所在的主机要将请求交给哪个服务。默认情况下http服务的端口为80，不需要在url中输入，如果web服务器采用的不是这一个默认端口，就需要写明服务所用的端口。常见的协议默认端口如下：协议类型默认端口http80ftp21https443telnet23IP是什么IP是因特网中的每台连接到网络的计算机为实现相互通信而遵循的规则协议。每个处于互联网中的设备都有IP 地址，形如 192.168.0.1，而127.0.0.1代表本机的 IP。IP又分为局域网IP和公网IP。而局域网 IP 和公网 IP 是有差别的。每个网站就是靠IP来定位的。为了便于记忆或辨识，人们使用域名来登录网站，每个域名背后有对应的IP地址。比如对于 http://www.jianshu.com的URL，浏览器实际上不知道 www.jianshu.com到底是什么东西，需要查找www.jianshu.com网站所在服务器的IP地址，才能找到目标，这就是下文要说的域名解析。二、域名解析当用户在浏览器中输入url后查找浏览器缓存浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。Chrome浏览器看本身的DNS缓存时间比较方便，在地址栏输入chrome://net-internals/#dns，就可以看到了查找操作系统缓存如果用户的浏览器缓存中没有，浏览器会从hosts文件查找是否有存储DNS信息，查找是否有目标域名和对应的IP地址查找路由器缓存如果系统缓存中也找不到，那么查询请求就会发向路由器，路由器一般会有自己的DNS缓存。查找ISP DNS 缓存如果路由器缓存中也找不到，那么就查询ISP DNS 缓存服务器了。我们都知道在我们的网络配置中都会有”DNS服务器地址”这一项，操作系统会把这个域名发送给这里设置的DNS，比如114.114.114.114,也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。而114.114.114.114是国内移动、电信和联通通用的DNS。递归查找如果前面都找不到DNS缓存的话，会有以下几个步骤：本地 DNS服务器将该请求转发到互联网上的根域（根域没有名字，在DNS系统中就用一个空字符串来表示。例如www.baidu.com.现在的DNS系统都不会要求域名以.来结束，即www.baidu.com就可以解析了，但是现在很多DNS解析服务商还是会要求在填写DNS记录的时候以.来结尾域名。）根域将所要查询域名中的顶级域（比如要查询www.baidu,com，该域名的顶级域就是com）的服务器IP地址返回到本地DNS。本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求， com域服务器再将域名中的二级域（即www.baidu.com中的baidu.com）的IP地址返回给本地DNS。本地DNS再向二级域发送请求进行查询。之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。下图能很好的说明这个递归查找:当查找到对应的IP地址之后，通过IP地址查找到对应的服务器，浏览器将用户发起的http请求发送给服务器。例如：GET http://www.baidu.com/ HTTP/1.1三、服务器处理请求每台服务器上都会安装处理请求的应用——Web server。常见的web server产品有apache、nginx、IIS、Lighttpd等。当web server接收到一个HTTP请求(request)，会返回一个HTTP响应(response)，例如送回一个HTML页面。对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理对应请求的程序进行处理（例如CGI脚本，JSP脚本，servlets，ASP脚本，服务器端JavaScript，或者一些其它的服务器端技术等）。无论它们(脚本)的目的如何，这些服务器端(server-side)的程序通常产生一个HTML的响应(response)来让浏览器可以浏览。那么如何处理请求？实际上就是后台处理的工作。后台开发现在有很多框架，但大部分都还是按照MVC设计模式进行搭建的。处理的过程如下图：MVC的处理过程是这样的：对于每一个用户输入的请求，首先被控制器接收，控制器决定用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器确定用哪个视图模型，用相应的视图格式化模型返回html字符串给浏览器，并通过显示页面呈现给用户。四、浏览器处理接下来就是浏览器进行处理， 通过后台处理返回的HTML字符串被浏览器接受后被一句句读取解析，html页面经历加载、解析、渲染。加载浏览器对一个html页面的加载顺序是从上而下的。如果加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。解析解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树，也就是DOM树。如下图：css解析是指将css文件解析为样式表对象。如下图：js解析是文件在加载的同时也进行解析如果想深入如何解析的话可以看浏览器的工作原理：新式网络浏览器幕后揭秘这篇文章渲染即为构建渲染树的过程，就是将DOM树进行可视化表示。构建这棵树是为了以正确的顺序绘制文档内容。五、绘制网页浏览器根据 HTML 和 CSS 计算得到渲染树，最终绘制到屏幕上参考的文章：前端经典面试题: 从输入URL到页面加载发生了什么？What really happens when you navigate to a URL从URL输入到页面展现MVC模型结构是什么域名详解浏览器~加载，解析，渲染由于本人的能力有限，如果哪里写的不对的话，请指出！感谢您的观看😀]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习笔记之js中apply()和call()方法详解]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bjs%E4%B8%ADapply()%E5%92%8Ccall()%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[经过网上的大量搜索，渐渐明白了apply()和call方法的使用，为此写一篇文章记录一下。定义apply()方法：Function.apply(obj,args)obj：这个对象将代替Function类里this对象args：这个是数组，它将作为参数传给Function(args–&gt;arguments）call()方法：Function.call(obj,[param1[,param2[,…[,paramN]]]])obj：这个对象将代替Function类里this对象params：这个是一个参数列表相同点与不同点相同点作用是一样的，call 和 apply 都是为了改变函数体内部 this 的指向，也就是把Function(即this)绑定到obj，这时候obj具备了Function的属性和方法，说白一点就是obj继承了Function的属性和方法。不同点相信大家也已经发现了，他们唯一区别就是接受参数的方式不太一样，apply接受的是数组参数，call接受的是连续参数。方法使用我们来看下面一个例子：定义一个函数mul123function mul(a,b)&#123; return this+(a*b);&#125;接着我们在控制台上打印出12345console.log(mul.call(null,2,3));console.log(mul.call('s',2,3));console.log(mul.call(3,2,3));console.log(mul.apply(null,[2,5]));console.log(mul.apply(2,[2,5]));分别为：[object Window]6s69[object Window]1012可能你会发现到，第一行 console.log(mul.call(null,2,3)) 没什么变化，call()的第一个参数就是改变的 this 指向，如果为 null 则函数的 this 不变，注意，如果在严格模式下（函数体或全局的开头有这句话：’use strict’），this 会变成 null。如果函数本身有参数，则从 call 的第二个参数开始写起。第二行 console.log(mul.call(‘s’,2,3)) 将函数的 this 指向一个字符串 ‘s’. ===&gt;&gt; ‘s’+2 * 3=s6第三行 console.log(mul.call(3,2,3)) 将函数的this指向一个数字3===&gt;&gt; 3+2 * 3=9以此类推。再举一个例子学js的都知道 Math.max() 方法,比如有三个参数2,3,4那么我们要找出最大值可以这么写 Math.max(2,3,4) 那要是有 100 个或更多参数呢？这时候就可以结合 apply 和数组轻松实现了。比如定义一个数组var arr=[2,3,4,5,6,7,8,9,10,23,45,66,22,11];接着我们打印出console.log(Math.max.apply(null,arr));这样一来就很简洁明了。再举一个例子实现对象继承1234567891011function Person(name,age) &#123; this.name=name; this.age=age;&#125;var Student=function(name,age,gender) &#123; Person.call(this,name,age);//this继承了person的属性和方法 this.gender=gender;&#125;var student=new Student("陈安东", 20, "男");alert("姓名:"+student.name+"\n"+"年龄:"+student.age+"\n"+"性别:"+student.gender);输出姓名:陈安东年龄:20性别:男这样用call就实现了继承（用apply也类似）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯-最大子阵]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%9C%80%E5%A4%A7%E5%AD%90%E9%98%B5.html</url>
    <content type="text"><![CDATA[问题给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。其中，A的子矩阵指在A中行和列均连续的一块。输入格式输入的第一行包含两个整数n, m，分别表示矩阵A的行数和列数。接下来n行，每行m个整数，表示矩阵A。输出格式输出一行，包含一个整数，表示A中最大的子矩阵中的元素和。样例输入3 3-1 -4 33 4 -1-5 -2 8样例输出10样例说明取最后一列，和为10。数据规模和约定对于50%的数据，1&lt;=n, m&lt;=50；对于100%的数据，1&lt;=n, m&lt;=500，A中每个元素的绝对值不超过5000。思路这题我是用动态规划求解，如下图，假设最大子矩阵的结果为从第r行到k行、从第i列到j列的子矩阵，如下所示(ari表示a[r][i],假设数组下标从1开始)：12345678910| a11 …… a1i ……a1j ……a1n || a21 …… a2i ……a2j ……a2n || ......................|| ...................... || ar1 …… ari ……arj ……arn || ......................|| ...................... || ak1 …… aki ……akj ……akn || ......................|| an1 …… ani ……anj ……ann |那么我们将从第r行到第k行的每一行中相同列的加起来，可以得到一个一维数组如下：(ar1+……+ak1, ar2+……+ak2, ……,arn+……+akn)，那么从中我们就可以把一个求子矩阵 的问题转换成一个求最大子段和 的问题，从中求出解。那么问题又来了，什么是最大子段和？怎么求最大子段和？首先，我们看一个问题：给定n个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n],求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值比如当（a1,a2,a3,a4,a4,a6）=(-1,11,-1,13,-5,-2)时，最大子段和就为23。用动态算法求解:b[j]=max{a[i]+a[j]},1&lt;=i&lt;=j,且1&lt;=j&lt;=n,则所求的最大子段和为max b[j]，1&lt;=j&lt;=n。由b[j]的定义可易知，当b[j-1]&gt;0时b[j]=b[j-1]+a[j]，否则b[j]=a[j]。故b[j]的动态规划递归式为:b[j]=max(b[j-1]+a[j],a[j])，1&lt;=j&lt;=n。最大子段和算法123456789101112int getMaxArray(int a[],int n)&#123;//求最大子段和 int max=a[0],temp=0; for (int i=0;i&lt;n;i++) &#123; if (temp&gt;0) &#123; temp+=a[i]; &#125;else &#123; temp=a[i]; &#125; max=max&gt;temp?max:temp; &#125; return max;&#125;实现代码12345678910111213141516171819202122232425262728293031323334353637#include "stdio.h"#include&lt;string.h&gt;int dp[100];int getMaxArray(int a[],int n)&#123;//求最大子段和 int max=a[0],temp=0; for (int i=0;i&lt;n;i++) &#123; if (temp&gt;0) &#123; temp+=a[i]; &#125;else &#123; temp=a[i]; &#125; max=max&gt;temp?max:temp; &#125; return max;&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int a[n][m]; for(int i=0;i&lt;n;i++)&#123; for (int j=0;j&lt;m;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; int res=a[0][0],tmp; for (int i=0;i&lt;n;i++) &#123; memset(dp, 0, sizeof(dp));//将dp数组置为0 for (int j = i; j &lt; n; ++j) &#123; for (int k = 0; k &lt; m; ++k) &#123; dp[k] += a[j][k]; &#125; tmp = getMaxArray(dp, n); res = res &gt; tmp ? res : tmp; &#125; &#125; printf("%d\n", res);&#125;]]></content>
      <categories>
        <category>c-c++</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯-四平方和问题]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[问题：四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多4个正整数的平方和。如果把0包括进去，就正好可以表示为4个数的平方和。比如：5 = 0^2 + 0^2 + 1^2 + 2^27 = 1^2 + 1^2 + 1^2 + 2^2（ ^ 符号表示乘方的意思）对于一个给定的正整数，可能存在多种平方和的表示法。要求你对4个数排序：0 &lt;= a &lt;= b &lt;= c &lt;= d并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法程序输入为一个正整数N (N&lt;5000000)要求输出4个非负整数，按从小到大排序，中间用空格分开例如，输入：5则程序应该输出：0 0 1 2再例如，输入：12则程序应该输出：0 2 2 2再例如，输入：773535则程序应该输出：1 1 267 838资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 3000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。思路：这题我是用暴力输出的，用四个循环，我先前用四个循环是从小加到大，但是超时了。我发现，输入的数越大，输出的前两个数是比较小的，但是后面两个数比较大，于是我把后面两个循环变成从大减到小，于是成功了╮(￣▽￣)╭实现代码（用C语言实现）1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;math.h&gt;void solve(long n)&#123; int a[4]; for (a[0]=0; a[0]&lt;sqrt(n); a[0]++) &#123; for (a[1]=a[0];a[1]&lt;sqrt(n) ; a[1]++) &#123; for (a[2]=sqrt(n-a[1]*a[1]-a[0]*a[0]); a[2]&gt;=a[1]; a[2]--) &#123; for (a[3]=sqrt(n-a[1]*a[1]-a[2]*a[2]-a[0]*a[0])+1; a[3]&gt;=a[2]; a[3]--) &#123;//其实这里加1不加1都一样 if (a[0]*a[0]+a[1]*a[1]+a[2]*a[2]+a[3]*a[3]==n) &#123; printf("%d %d %d %d\n",a[0],a[1],a[2],a[3]); return ; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; long n; scanf("%ld",&amp;n); solve(n); return 0;&#125;]]></content>
      <categories>
        <category>c-c++</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯-生日蜡烛]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%94%9F%E6%97%A5%E8%9C%A1%E7%83%9B.html</url>
    <content type="text"><![CDATA[问题生日蜡烛某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。现在算起来，他一共吹熄了236根蜡烛。请问，他从多少岁开始过生日party的？请填写他开始过生日party的年龄数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。思路这题比较容易，方法是用两个for循环实现，第一个循环从i=1开始，第二个循环可以从j=i开始，内存循环sum+=j;而如果sum不等于236的话，在外层循环中将sum置为0就可以了实现代码(c语言)12345678910111213#include&lt;stdio.h&gt;int main()&#123; int i,sum = 0,j; for (i=1; i&lt;=100;i++) &#123; for(j=i;j&lt;=100;j++)&#123; sum+=j; if (sum==236) &#123; printf("%d",i); &#125; &#125; sum=0; &#125;&#125;]]></content>
      <categories>
        <category>c-c++</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯 三羊献瑞]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E4%B8%89%E7%BE%8A%E7%8C%AE%E7%91%9E.html</url>
    <content type="text"><![CDATA[问题观察下面的加法算式：123456 祥 瑞 生 辉 + 三 羊 献 瑞================= 三 羊 生 瑞 气其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字，‘三’和‘祥’不能为 0。请你计算出“三羊献瑞”所代表的 4 位数是什么。（答案唯一）注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字，行末不要换行。思路这题我是直接用暴力法求解的(￣▽￣)”实现代码1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;int main()&#123; int x,r,s,h,san,yan,xian,qi,sum1,sum2,sum3; for (x=1; x&lt;=9;x++) &#123; for (r=0; r&lt;=9; r++) &#123; for (s=0; s&lt;=9; s++) &#123; for (h=0; h&lt;=9; h++) &#123; for (san=1; san&lt;=9; san++) &#123; for (yan=0; yan&lt;=9; yan++) &#123; for (xian=0; xian&lt;=9; xian++) &#123; for (qi=0; qi&lt;=9; qi++) &#123; sum1=x*1000+r*100+s*10+h; sum2=san*1000+yan*100+xian*10+r; sum3=san*10000+yan*1000+s*100+r*10+qi; if (sum1+sum2==sum3 &amp;&amp; x!=r &amp;&amp; x!=s &amp;&amp; x!=h &amp;&amp; x!=san &amp;&amp; x!=yan &amp;&amp; x!=xian &amp;&amp; x!=qi &amp;&amp; r!=s &amp;&amp; r!=h &amp;&amp; r!=san &amp;&amp; r!=h &amp;&amp; r!=san &amp;&amp; r!=yan &amp;&amp; r!=xian &amp;&amp; r!=qi &amp;&amp;s!=h &amp;&amp; s!=san &amp;&amp; s!=yan &amp;&amp; s!=xian &amp;&amp; s!=qi &amp;&amp;h!=san &amp;&amp;h!=yan &amp;&amp;h!=xian &amp;&amp; h!=qi &amp;&amp;san!=yan &amp;&amp;san!=qi&amp;&amp; yan!=xian &amp;&amp; yan!=qi &amp;&amp;xian!=qi) &#123; printf("%d+%d=%d\n",sum1,sum2,sum3); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>c-c++</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题如何添加动态背景]]></title>
    <url>%2Fhexo%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF.html</url>
    <content type="text"><![CDATA[注意：如果next主题在5.1.1以上的话就不用我这样设置，直接在主题配置文件中找到canvas_nest: false，把它改为canvas_nest: true就行了（注意分号后面要加一个空格）其实挺简单的︿(￣︶￣)︿修改_layout.swig打开 next/layout/_layout.swig在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面)123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125;修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面)123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/如果你感觉默认的线条太多的话可以这么设置====&gt;在上一步修改 _layout.swig中，把刚才的这些代码：123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125;改为1234&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript"color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125;配置项说明color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B)opacity: 线条透明度（0~1）, 默认: 0.5count: 线条的总数量, 默认: 150zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯 李白喝酒]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%20%E6%9D%8E%E7%99%BD%E5%96%9D%E9%85%92%EF%BC%81.html</url>
    <content type="text"><![CDATA[问题话说大诗人李白，一生好饮。幸好他从不开车。一天，他提着酒壶，从家里出来，酒壶中有酒两斗。他边走边唱：无事街上走，提壶去打酒。逢店加一倍，遇花喝一斗。这一路上，他一共遇到店 55 次，遇到花 1010 次，已知最后一次遇到的是花，他正好把酒喝光了。请你计算李白遇到店和花的次序，有多少种可能的方案。思路我们已知遇店 5 次，遇花 10 次，并且最后一次遇到花，正好把酒喝光。那么我们可以把店作为二进制中的 1，把花作为二进制中的 0，因为已经确定最后一次遇到的是花，所以我们需要判断枚举的结果是否刚好有 5个 1 和 9个 0。那么我们就枚举出 14 位二进制的所有可能并加以判断即可，判断思路为判断二进制是否有 9 个 0，5个 1，并且最终酒刚好剩 1 斗实现代码12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int ans=0;//方案数 for (int i=0; i&lt;(1&lt;&lt;14); i++) &#123; int dian=0;//表示遇到店的次数 int hua=0;//表示遇到话的次数 int num=2;//初始酒壶有两斗 for (int j=0;j&lt;14 ;j++) &#123; if (i&amp;(1&lt;&lt;j)) &#123;//这里判断二进制i从右数第j+1为是否为1 dian++;//遇到店，次数加1 num*=2;//加一倍 &#125;else&#123; hua++;//遇到花，次数加1 num-=1;//喝一斗 &#125; &#125; if (dian==5&amp;&amp;hua==9&amp;&amp;num==1) &#123; ++ans;//记录方法数 &#125; &#125; printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>c-c++</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
</search>
